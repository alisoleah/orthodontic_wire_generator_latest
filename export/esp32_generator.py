
# ================================================================
# export/esp32_generator.py
"""ESP32 Arduino code generation for stepper motor control."""

import numpy as np
import time
from typing import Tuple, Optional

class ESP32Generator:
    """Generates Arduino code for ESP32-based wire forming machines."""
    
    def __init__(self):
        """Initialize ESP32 code generator."""
        self.default_settings = {
            'steps_per_mm': (80, 80, 400),  # X, Y, Z axes
            'pins': ((26, 27), (32, 33), (14, 12)),  # (step, dir) for each axis
            'max_feed_mm_s': 5.0,
            'accel_steps_s2': 800.0
        }
    
    def generate(self, wire_path: np.ndarray, arch_type: str, wire_size: str,
                steps_per_mm: Tuple = None, pins: Tuple = None, 
                max_feed_mm_s: float = None) -> str:
        """Generate complete ESP32 Arduino code."""
        
        if steps_per_mm is None:
            steps_per_mm = self.default_settings['steps_per_mm']
        if pins is None:
            pins = self.default_settings['pins']
        if max_feed_mm_s is None:
            max_feed_mm_s = self.default_settings['max_feed_mm_s']
        
        return self._generate_arduino_code(wire_path, steps_per_mm, pins, 
                                         max_feed_mm_s, arch_type, wire_size)
    
    def _generate_arduino_code(self, wire_path: np.ndarray, steps_per_mm: Tuple,
                             pins: Tuple, max_feed_mm_s: float, 
                             arch_type: str, wire_size: str) -> str:
        """Generate the complete Arduino sketch."""
        
        # Convert path to array format for Arduino
        path_array = self._format_path_array(wire_path)
        
        code = f'''/*
 * Auto-generated ESP32 Arduino Code
 * Generated by Modular Orthodontic Wire Generator
 * Date: {time.strftime('%Y-%m-%d %H:%M:%S')}
 * 
 * Wire: {wire_size} {arch_type} arch
 * Purpose: Control 3 stepper motors along 3D wire path
 * Hardware: ESP32 + AccelStepper library
 */

#include <AccelStepper.h>

// Hardware Configuration
#define X_STEP_PIN {pins[0][0]}
#define X_DIR_PIN  {pins[0][1]}
#define Y_STEP_PIN {pins[1][0]}
#define Y_DIR_PIN  {pins[1][1]}
#define Z_STEP_PIN {pins[2][0]}
#define Z_DIR_PIN  {pins[2][1]}

// Motion Parameters
const float X_STEPS_PER_MM = {float(steps_per_mm[0])}f;
const float Y_STEPS_PER_MM = {float(steps_per_mm[1])}f;
const float Z_STEPS_PER_MM = {float(steps_per_mm[2])}f;
const float MAX_FEED_MM_S = {max_feed_mm_s:.3f}f;
const float ACCEL_STEPS_S2 = {self.default_settings['accel_steps_s2']:.1f}f;

// Wire Path Data
struct Waypoint {{
  float x, y, z;
}};

const Waypoint WIRE_PATH[] = {{
{path_array}
}};

const int PATH_LENGTH = sizeof(WIRE_PATH) / sizeof(WIRE_PATH[0]);

// Stepper Objects
AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);
AccelStepper stepperZ(AccelStepper::DRIVER, Z_STEP_PIN, Z_DIR_PIN);

long mmToSteps(float mm, float stepsPerMm) {{
  return (long)round(mm * stepsPerMm);
}}

void moveToPosition(float x_mm, float y_mm, float z_mm, float feedRate_mm_s) {{
  if (feedRate_mm_s <= 0) feedRate_mm_s = MAX_FEED_MM_S;
  if (feedRate_mm_s > MAX_FEED_MM_S) feedRate_mm_s = MAX_FEED_MM_S;
  
  long targetX = mmToSteps(x_mm, X_STEPS_PER_MM);
  long targetY = mmToSteps(y_mm, Y_STEPS_PER_MM);
  long targetZ = mmToSteps(z_mm, Z_STEPS_PER_MM);
  
  stepperX.moveTo(targetX);
  stepperY.moveTo(targetY);
  stepperZ.moveTo(targetZ);
  
  stepperX.setAcceleration(ACCEL_STEPS_S2);
  stepperY.setAcceleration(ACCEL_STEPS_S2);
  stepperZ.setAcceleration(ACCEL_STEPS_S2);
  
  while (stepperX.distanceToGo() != 0 || 
         stepperY.distanceToGo() != 0 || 
         stepperZ.distanceToGo() != 0) {{
    stepperX.run();
    stepperY.run();
    stepperZ.run();
  }}
}}

void setup() {{
  Serial.begin(115200);
  
  stepperX.setMaxSpeed(2000);
  stepperY.setMaxSpeed(2000);
  stepperZ.setMaxSpeed(2000);
  
  stepperX.setCurrentPosition(0);
  stepperY.setCurrentPosition(0);
  stepperZ.setCurrentPosition(0);
  
  Serial.println("ESP32 Wire Former Ready");
  Serial.print("Path points: ");
  Serial.println(PATH_LENGTH);
  
  // Execute path
  for (int i = 0; i < PATH_LENGTH; i++) {{
    Serial.print("Point ");
    Serial.print(i + 1);
    Serial.print("/");
    Serial.println(PATH_LENGTH);
    
    moveToPosition(WIRE_PATH[i].x, WIRE_PATH[i].y, WIRE_PATH[i].z, MAX_FEED_MM_S);
    delay(100);
  }}
  
  Serial.println("Path complete!");
}}

void loop() {{
  // Idle
}}
'''
        
        return code
    
    def _format_path_array(self, wire_path: np.ndarray) -> str:
        """Format wire path as Arduino array."""
        if wire_path is None or len(wire_path) == 0:
            return "  // No path data"
        
        array_lines = []
        for i, point in enumerate(wire_path):
            line = f"  {{ {point[0]:.4f}f, {point[1]:.4f}f, {point[2]:.4f}f }}"
            if i < len(wire_path) - 1:
                line += ","
            array_lines.append(line)
        
        return "\n".join(array_lines)

