#!/usr/bin/env python3
"""
Export Components for Wire Generation
====================================
Handles all export functionality including G-code, ESP32 code, and STL files.
"""

# ================================================================
# export/gcode_generator.py
"""G-code generation for CNC wire bending machines."""

import numpy as np
import time
from typing import List, Dict, Optional

class GCodeGenerator:
    """Generates G-code for Arduino-controlled wire bending machines."""
    
    def __init__(self):
        """Initialize G-code generator."""
        self.settings = {
            'feed_rate': 1000,      # mm/min
            'bend_speed': 500,      # mm/min
            'safety_height': 10.0,  # mm
            'wire_clamp_pos': [10, 0, 0],
            'home_position': [0, 0, 0]
        }
        
    def generate(self, wire_path: np.ndarray, bends: List[Dict], wire_length: float,
                height_offset: float, arch_type: str, wire_size: str) -> str:
        """
        Generate complete G-code for wire bending and return it as a string.
        """
        # Generate G-code content
        gcode_lines = self._generate_header(wire_size, arch_type, wire_length, 
                                          height_offset, len(bends))
        gcode_lines.extend(self._generate_initialization())
        gcode_lines.extend(self._generate_wire_preparation())
        gcode_lines.extend(self._generate_bending_operations(bends))
        gcode_lines.extend(self._generate_completion(wire_length, bends))
        
        return '\n'.join(gcode_lines)
    
    def _generate_header(self, wire_size: str, arch_type: str, wire_length: float,
                        height_offset: float, bend_count: int) -> List[str]:
        """Generate G-code header with metadata."""
        return [
            "; Generated by Modular Orthodontic Wire Generator",
            f"; Date: {time.strftime('%Y-%m-%d %H:%M:%S')}",
            f"; Wire Size: {wire_size}",
            f"; Arch Type: {arch_type.upper()}",
            f"; Total Wire Length: {wire_length:.2f}mm",
            f"; Wire Height Offset: {height_offset:.2f}mm",
            f"; Number of Bends: {bend_count}",
            f"; Feed Rate: {self.settings['feed_rate']} mm/min",
            f"; Bend Speed: {self.settings['bend_speed']} mm/min",
            f"; Safety Height: {self.settings['safety_height']}mm",
            ";",
            "; Machine Commands:",
            "; G0/G1 - Linear movement",
            "; M3 - Clamp wire",
            "; M4 - Release wire",
            "; M5 - Bend wire",
            "; M6 - Feed wire",
            ";",
        ]
    
    def _generate_initialization(self) -> List[str]:
        """Generate initialization commands."""
        return [
            "",
            "; === INITIALIZATION ===",
            "G21 ; Set units to millimeters",
            "G90 ; Absolute positioning",
            "G28 ; Home all axes",
            f"F{self.settings['feed_rate']} ; Set default feed rate",
            "M117 Wire Bending Started",
            "",
        ]
    
    def _generate_wire_preparation(self) -> List[str]:
        """Generate wire preparation commands."""
        pos = self.settings['wire_clamp_pos']
        safety = self.settings['safety_height']
        
        return [
            "; === WIRE PREPARATION ===",
            f"G0 Z{safety} ; Move to safety height",
            f"G0 X{pos[0]} Y{pos[1]} Z{safety}",
            f"G1 Z{pos[2]} F{self.settings['bend_speed']}",
            "M3 ; Clamp wire",
            "G4 P500 ; Wait 0.5 seconds",
            "",
        ]
    
    def _generate_bending_operations(self, bends: List[Dict]) -> List[str]:
        """Generate bending operation commands."""
        commands = []
        current_wire_length = 0.0
        
        for i, bend in enumerate(bends):
            feed_length = bend['wire_length'] - current_wire_length
            
            commands.extend([
                f"; === BEND {i+1}: {bend['angle']:.1f}Â° {bend['direction']} ===",
                f"M6 S{feed_length:.2f} ; Feed wire {feed_length:.2f}mm",
                "G4 P200 ; Wait for wire feed",
                "",
                "; Position bending mechanism",
                f"G0 Z{self.settings['safety_height']} ; Safety height",
                f"G0 X{bend['position'][0]:.2f} Y{bend['position'][1]:.2f}",
                f"G1 Z{bend['position'][2]:.2f} F{self.settings['bend_speed']}",
                "",
                "; Execute bend",
                f"M5 A{bend['angle']:.1f} R{bend['radius']:.1f} D{bend['direction'][0].upper()}",
                "G4 P1000 ; Wait for bend completion",
                "",
                "; Return to safe position",
                f"G0 Z{self.settings['safety_height']}",
                "",
            ])
            
            current_wire_length = bend['wire_length']
        
        return commands
    
    def _generate_completion(self, total_wire_length: float, bends: List[Dict]) -> List[str]:
        """Generate completion commands."""
        current_length = bends[-1]['wire_length'] if bends else 0
        remaining_length = total_wire_length - current_length
        estimated_time = self._estimate_time(bends, total_wire_length)
        
        return [
            "; === COMPLETION ===",
            f"M6 S{remaining_length:.2f} ; Feed remaining wire",
            "G4 P500 ; Wait for final feed",
            "",
            "; Cleanup",
            "M4 ; Release wire clamp",
            f"G0 Z{self.settings['safety_height']} ; Safety height",
            "G28 ; Return home",
            "M117 Wire Bending Complete",
            "",
            f"; === SUMMARY ===",
            f"; Total wire used: {total_wire_length:.2f}mm",
            f"; Total bends: {len(bends)}",
            f"; Estimated time: {estimated_time:.1f} minutes",
            "",
            "M30 ; Program end",
        ]
    
    def _estimate_time(self, bends: List[Dict], wire_length: float) -> float:
        """Estimate total operation time in minutes."""
        setup_time = 30  # seconds
        feed_time = wire_length / 10  # 10mm/s feed rate
        bend_time = len(bends) * 5  # 5 seconds per bend
        positioning_time = len(bends) * 3  # 3 seconds positioning
        
        total_seconds = setup_time + feed_time + bend_time + positioning_time
        return total_seconds / 60
    
    def update_settings(self, **kwargs):
        """Update G-code generation settings."""
        self.settings.update(kwargs)


# ================================================================
# export/esp32_generator.py
"""ESP32 Arduino code generation for stepper motor control."""

import numpy as np
import time
from typing import Tuple

class ESP32Generator:
    """Generates Arduino code for ESP32-based wire forming machines."""
    
    def __init__(self):
        """Initialize ESP32 code generator."""
        self.default_settings = {
            'steps_per_mm': (80, 80, 400),  # X, Y, Z axes
            'pins': ((26, 27), (32, 33), (14, 12)),  # (step, dir) for each axis
            'max_feed_mm_s': 5.0,
            'accel_steps_s2': 800.0
        }
    
    def generate(self, wire_path: np.ndarray, arch_type: str, wire_size: str,
                steps_per_mm: Tuple = None, pins: Tuple = None, 
                max_feed_mm_s: float = None) -> str:
        """Generate complete ESP32 Arduino code."""
        
        if steps_per_mm is None:
            steps_per_mm = self.default_settings['steps_per_mm']
        if pins is None:
            pins = self.default_settings['pins']
        if max_feed_mm_s is None:
            max_feed_mm_s = self.default_settings['max_feed_mm_s']
        
        return self._generate_arduino_code(wire_path, steps_per_mm, pins, 
                                         max_feed_mm_s, arch_type, wire_size)
    
    def _generate_arduino_code(self, wire_path: np.ndarray, steps_per_mm: Tuple,
                             pins: Tuple, max_feed_mm_s: float, 
                             arch_type: str, wire_size: str) -> str:
        """Generate the complete Arduino sketch."""
        
        # Convert path to array format for Arduino
        path_array = self._format_path_array(wire_path)
        
        code = f'''/*
 * Auto-generated ESP32 Arduino Code
 * Generated by Modular Orthodontic Wire Generator
 * Date: {time.strftime('%Y-%m-%d %H:%M:%S')}
 * 
 * Wire: {wire_size} {arch_type} arch
 * Purpose: Control 3 stepper motors along 3D wire path
 * Hardware: ESP32 + AccelStepper library
 * 
 * IMPORTANT: Adjust pins, steps/mm, speeds for your hardware!
 */

#include <AccelStepper.h>

// ================ HARDWARE CONFIGURATION ================
// Stepper pin definitions (EDIT FOR YOUR SETUP)
#define X_STEP_PIN {pins[0][0]}
#define X_DIR_PIN  {pins[0][1]}
#define Y_STEP_PIN {pins[1][0]}
#define Y_DIR_PIN  {pins[1][1]}
#define Z_STEP_PIN {pins[2][0]}
#define Z_DIR_PIN  {pins[2][1]}

// Motion parameters (ADJUST FOR YOUR MACHINE)
const float X_STEPS_PER_MM = {float(steps_per_mm[0])}f;
const float Y_STEPS_PER_MM = {float(steps_per_mm[1])}f;
const float Z_STEPS_PER_MM = {float(steps_per_mm[2])}f;

const float MAX_FEED_MM_S = {max_feed_mm_s:.3f}f;  // Maximum feed rate
const float ACCEL_STEPS_S2 = {self.default_settings['accel_steps_s2']:.1f}f;  // Acceleration

// ================ WIRE PATH DATA ================
struct Waypoint {{
  float x, y, z;
}};

const Waypoint WIRE_PATH[] = {{
{path_array}
}};

const int PATH_LENGTH = sizeof(WIRE_PATH) / sizeof(WIRE_PATH[0]);

// ================ STEPPER OBJECTS ================
AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);
AccelStepper stepperZ(AccelStepper::DRIVER, Z_STEP_PIN, Z_DIR_PIN);

// ================ UTILITY FUNCTIONS ================
long mmToSteps(float mm, float stepsPerMm) {{
  return (long)round(mm * stepsPerMm);
}}

void moveToPosition(float x_mm, float y_mm, float z_mm, float feedRate_mm_s) {{
  // Clamp feed rate
  if (feedRate_mm_s <= 0) feedRate_mm_s = MAX_FEED_MM_S;
  if (feedRate_mm_s > MAX_FEED_MM_S) feedRate_mm_s = MAX_FEED_MM_S;
  
  // Convert to steps
  long targetX = mmToSteps(x_mm, X_STEPS_PER_MM);
  long targetY = mmToSteps(y_mm, Y_STEPS_PER_MM);
  long targetZ = mmToSteps(z_mm, Z_STEPS_PER_MM);
  
  // Calculate movement vector
  long deltaX = targetX - stepperX.currentPosition();
  long deltaY = targetY - stepperY.currentPosition();
  long deltaZ = targetZ - stepperZ.currentPosition();
  
  // Calculate vector magnitude
  double vectorLength = sqrt((double)deltaX*deltaX + (double)deltaY*deltaY + (double)deltaZ*deltaZ);
  
  if (vectorLength < 1.0) {{
    // Very small movement, just move directly
    stepperX.moveTo(targetX);
    stepperY.moveTo(targetY);
    stepperZ.moveTo(targetZ);
    stepperX.runToPosition();
    stepperY.runToPosition();
    stepperZ.runToPosition();
    return;
  }}
  
  // Calculate proportional speeds
  double totalStepsPerMm = (X_STEPS_PER_MM + Y_STEPS_PER_MM + Z_STEPS_PER_MM) / 3.0;
  double feedStepsPerSec = feedRate_mm_s * totalStepsPerMm;
  
  double speedX = feedStepsPerSec * abs(deltaX) / vectorLength;
  double speedY = feedStepsPerSec * abs(deltaY) / vectorLength;
  double speedZ = feedStepsPerSec * abs(deltaZ) / vectorLength;
  
  // Set target positions and speeds
  stepperX.moveTo(targetX);
  stepperY.moveTo(targetY);
  stepperZ.moveTo(targetZ);
  
  stepperX.setMaxSpeed(speedX);
  stepperY.setMaxSpeed(speedY);
  stepperZ.setMaxSpeed(speedZ);
  
  stepperX.setAcceleration(ACCEL_STEPS_S2);
  stepperY.setAcceleration(ACCEL_STEPS_S2);
  stepperZ.setAcceleration(ACCEL_STEPS_S2);
  
  // Execute coordinated movement
  while (stepperX.distanceToGo() != 0 || 
         stepperY.distanceToGo() != 0 || 
         stepperZ.distanceToGo() != 0) {{
    stepperX.run();
    stepperY.run();
    stepperZ.run();
  }}
}}

void homeAllAxes() {{
  // TODO: Implement homing with endstops if available
  // For now, just set current position as home
  stepperX.setCurrentPosition(0);
  stepperY.setCurrentPosition(0);
  stepperZ.setCurrentPosition(0);
  
  Serial.println("All axes homed (software home)");
}}

void printPathInfo() {{
  Serial.println("Wire Path Information:");
  Serial.print("Total waypoints: ");
  Serial.println(PATH_LENGTH);
  
  if (PATH_LENGTH > 0) {{
    Serial.print("Start point: (");
    Serial.print(WIRE_PATH[0].x, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[0].y, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[0].z, 2);
    Serial.println(")");
    
    Serial.print("End point: (");
    Serial.print(WIRE_PATH[PATH_LENGTH-1].x, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[PATH_LENGTH-1].y, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[PATH_LENGTH-1].z, 2);
    Serial.println(")");
  }}
}}

// ================ ARDUINO SETUP ================
void setup() {{
  // Initialize serial communication
  Serial.begin(115200);
  while (!Serial) delay(10);
  
  Serial.println("=== ESP32 Wire Former Starting ===");
  Serial.println("Generated by Modular Orthodontic Wire Generator");
  
  // Configure steppers
  stepperX.setMaxSpeed(2000);
  stepperX.setAcceleration(ACCEL_STEPS_S2);
  
  stepperY.setMaxSpeed(2000);
  stepperY.setAcceleration(ACCEL_STEPS_S2);
  
  stepperZ.setMaxSpeed(2000);
  stepperZ.setAcceleration(ACCEL_STEPS_S2);
  
  Serial.println("Steppers configured");
  
  // Home all axes
  homeAllAxes();
  
  // Print path information
  printPathInfo();
  
  // Execute wire path
  Serial.println("Starting wire path execution...");
  
  // Move to first point at safe speed
  if (PATH_LENGTH > 0) {{
    Serial.print("Moving to start position: ");
    Serial.print(WIRE_PATH[0].x, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[0].y, 2);
    Serial.print(", ");
    Serial.println(WIRE_PATH[0].z, 2);
    
    moveToPosition(WIRE_PATH[0].x, WIRE_PATH[0].y, WIRE_PATH[0].z, MAX_FEED_MM_S * 0.5f);
    delay(500);
  }}
  
  // Execute remaining path
  for (int i = 1; i < PATH_LENGTH; i++) {{
    Serial.print("Moving to waypoint ");
    Serial.print(i + 1);
    Serial.print("/");
    Serial.print(PATH_LENGTH);
    Serial.print(": (");
    Serial.print(WIRE_PATH[i].x, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[i].y, 2);
    Serial.print(", ");
    Serial.print(WIRE_PATH[i].z, 2);
    Serial.println(")");
    
    moveToPosition(WIRE_PATH[i].x, WIRE_PATH[i].y, WIRE_PATH[i].z, MAX_FEED_MM_S);
    
    // Small delay between movements
    delay(100);
  }}
  
  Serial.println("Wire path execution complete!");
  Serial.println("System ready for manual control or restart.");
}}

// ================ ARDUINO LOOP ================
void loop() {{
  // Main loop - system is idle after path execution
  // You can add manual control commands here if needed
  
  // Example: Check for serial commands
  if (Serial.available()) {{
    String command = Serial.readStringUntil('\\n');
    command.trim();
    
    if (command == "home") {{
      Serial.println("Homing all axes...");
      homeAllAxes();
    }}
    else if (command == "info") {{
      printPathInfo();
    }}
    else if (command == "restart") {{
      Serial.println("Restarting path execution...");
      ESP.restart();
    }}
    else {{
      Serial.println("Available commands: home, info, restart");
    }}
  }}
  
  delay(100);
}}

/*
 * USAGE INSTRUCTIONS:
 * 
 * 1. Connect steppers to the defined pins
 * 2. Adjust STEPS_PER_MM values for your specific steppers/mechanics
 * 3. Set appropriate MAX_FEED_MM_S for your system capabilities
 * 4. Upload to ESP32 and open Serial Monitor
 * 5. System will automatically execute the wire path
 * 
 * SERIAL COMMANDS (type in Serial Monitor):
 * - home: Re-home all axes
 * - info: Display path information
 * - restart: Restart the entire program
 * 
 * SAFETY NOTES:
 * - Test with low feed rates first
 * - Ensure mechanical limits are respected
 * - Add endstop homing for production use
 * - Monitor for motor stalls or binding
 */
'''
        
        return code
    
    def _format_path_array(self, wire_path: np.ndarray) -> str:
        """Format wire path as Arduino array."""
        if wire_path is None or len(wire_path) == 0:
            return "  // No path data"
        
        array_lines = []
        for i, point in enumerate(wire_path):
            line = f"  {{ {point[0]:.4f}f, {point[1]:.4f}f, {point[2]:.4f}f }}"
            if i < len(wire_path) - 1:
                line += ","
            array_lines.append(line)
        
        return "\n".join(array_lines)


# ================================================================
# export/stl_exporter.py
"""STL export functionality for wire meshes."""

import open3d as o3d
import numpy as np
import time
from pathlib import Path

class STLExporter:
    """Handles STL file export for wire meshes and components."""
    
    def __init__(self):
        """Initialize STL exporter."""
        self.export_settings = {
            'binary': True,  # Use binary STL format (smaller files)
            'precision': 6,  # Decimal precision for ASCII format
        }
    
    def export(self, mesh: o3d.geometry.TriangleMesh, filename: str, 
               include_metadata: bool = True) -> bool:
        """Export mesh to STL file."""
        try:
            # Ensure mesh is valid
            if not mesh.has_triangles():
                print("Error: Mesh has no triangles to export")
                return False
            
            # Clean mesh before export
            cleaned_mesh = self._prepare_mesh_for_export(mesh)
            
            # Add metadata to filename if requested
            if include_metadata:
                filename = self._add_metadata_to_filename(filename)
            
            # Export to STL
            success = o3d.io.write_triangle_mesh(filename, cleaned_mesh, 
                                               write_ascii=not self.export_settings['binary'])
            
            if success:
                file_size = Path(filename).stat().st_size
                print(f"STL exported successfully: {filename}")
                print(f"File size: {file_size / 1024:.1f} KB")
                print(f"Vertices: {len(cleaned_mesh.vertices)}")
                print(f"Triangles: {len(cleaned_mesh.triangles)}")
                return True
            else:
                print(f"Failed to export STL: {filename}")
                return False
                
        except Exception as e:
            print(f"STL export error: {e}")
            return False
    
    def _prepare_mesh_for_export(self, mesh: o3d.geometry.TriangleMesh) -> o3d.geometry.TriangleMesh:
        """Prepare mesh for export by cleaning and optimizing."""
        cleaned_mesh = mesh.copy()
        
        # Remove duplicated vertices and triangles
        cleaned_mesh.remove_duplicated_vertices()
        cleaned_mesh.remove_duplicated_triangles()
        cleaned_mesh.remove_degenerate_triangles()
        
        # Merge close vertices
        cleaned_mesh.merge_close_vertices(1e-6)
        
        # Compute normals for proper STL export
        cleaned_mesh.compute_vertex_normals()
        cleaned_mesh.compute_triangle_normals()
        
        return cleaned_mesh
    
    def _add_metadata_to_filename(self, filename: str) -> str:
        """Add timestamp and metadata to filename."""
        path = Path(filename)
        stem = path.stem
        suffix = path.suffix
        
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        new_filename = f"{stem}_{timestamp}{suffix}"
        
        return str(path.parent / new_filename)
    
    def export_wire_components(self, wire_mesh: o3d.geometry.TriangleMesh, 
                             bracket_meshes: list = None, 
                             base_filename: str = "wire_assembly") -> dict:
        """Export wire and brackets as separate STL files."""
        exported_files = {}
        
        # Export main wire
        if wire_mesh:
            wire_file = f"{base_filename}_wire.stl"
            if self.export(wire_mesh, wire_file):
                exported_files['wire'] = wire_file
        
        # Export brackets
        if bracket_meshes:
            for i, bracket_data in enumerate(bracket_meshes):
                bracket_file = f"{base_filename}_bracket_{i+1}.stl"
                if self.export(bracket_data['mesh'], bracket_file):
                    exported_files[f'bracket_{i+1}'] = bracket_file
        
        # Create combined assembly
        if wire_mesh and bracket_meshes:
            assembly_mesh = wire_mesh.copy()
            for bracket_data in bracket_meshes:
                assembly_mesh += bracket_data['mesh']
            
            assembly_file = f"{base_filename}_assembly.stl"
            if self.export(assembly_mesh, assembly_file):
                exported_files['assembly'] = assembly_file
        
        return exported_files
    
    def get_mesh_info(self, mesh: o3d.geometry.TriangleMesh) -> dict:
        """Get detailed information about a mesh."""
        if not mesh.has_triangles():
            return {'valid': False}
        
        bbox = mesh.get_axis_aligned_bounding_box()
        extent = bbox.get_extent()
        
        return {
            'valid': True,
            'vertex_count': len(mesh.vertices),
            'triangle_count': len(mesh.triangles),
            'surface_area': mesh.get_surface_area(),
            'volume': mesh.get_volume(),
            'bounding_box': {
                'min': bbox.min_bound.tolist(),
                'max': bbox.max_bound.tolist(),
                'extent': extent.tolist(),
                'center': mesh.get_center().tolist()
            },
            'is_watertight': mesh.is_watertight(),
            'is_orientable': mesh.is_orientable()
        }
    
    def update_export_settings(self, **kwargs):
        """Update export settings."""
        self.export_settings.update(kwargs)